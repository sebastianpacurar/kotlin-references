package functions

import kotlin.math.roundToInt

/*
 High-Order functions - functions that either take functions as params, return functions or do both:

  - forEach: similar to for loop, but by using lambda; iterates over values, no index
  - forEachIndexed: similar to forEach, but using index along with current value
  - filter: filter our desired elements from a Collection
  - filterIndexed: same as filter, but takes the index of the iterated element into account
  - map: perform operations, modify elements
  - mapIndexed: same as map, but takes the index of the iterated element into account
  - reduce: takes a binary operation (function which takes 2 params and returns a result)
  - fold: similar to reduce but allows specifying an initial value
  - takeWhile: returns a new Collection containing the sequence until a condition is met
  - flatMap: use map to traverse elements through a function then perform flatten()
  - flatMapIndexed: similar to flatMap(), but provides the index of each element along with the elem itself to the transformation function
  - partition: splits a collection into two separate collections based on a predicate
  - maxBy: returns the element with the maximum value of a Collection based on a specific selector
  - maxByOrNull: return the max value of a Collection based on a specific selector
  - minBy: returns the element with the minimum value of a Collection based on a specific selector
  - minByOrNull: return the min value of a Collection based on a specific selector
  - sumOf: returns the sum of the results of applying a transformation function to each element of a collection
  - indexOfFirst: find the index of the first element in a collection that satisfies a given predicate. if element not found it returns -1
  - indexOfLast: find the index of the last element in a collection that satisfies a given predicate. if element not found it returns -1
  - first: returns the first element of a Collection that matches the given predicate
  - firstOrNull: returns the first element of an indexed collection, or null if element not found
  - last: returns the last element of a Collection that matches the given predicate
  - lastOrNull: returns the last element of the indexed collection, or null if element not found
  - groupBy: groups elements of a collection by a specified key or criteria
  - groupingBy: returns a Grouping object, on which aggregation functions can be performed
  - sortedBy: returns a list of elements sorted by the result of a selector function
  - sortedByDescending: returns a list of elements sorted by the result of a selector function in descending order
  - associate: creates a Map from the elements of the Collection and their corresponding values
  - associateTo: populates an existing mutable Map with key-value pairs derived from a collection
  - associateBy: creates a Map from the elements of the Collection with keys generated by the keySelector function
  - associateByTo: populate an existing mutable map with key-value pairs derived from a collection using a key selector function
  - associateWith: creates a Map from the elements of the Collection with values generated by the valueTransform function
  - associateWithTo: populate an existing mutable map with key-value pairs derived from a collection using a valueTransform function
  - distinctBy: returns a list of distinct elements based on the provided selector

*/


fun main() {
    println("ForEach and ForEachIndexed examples")
    forEachLoops()

    println("\nMap and Filter examples")
    mapAndFilter()

    println("\nMapIndexed example")
    mapIndexedFunc()

    println("\nFilterIndexed example")
    filterIndexedFunc()

    println("\nReduce and Fold examples")
    reduceAndFoldFuncs()

    println("\nTakeWhile examples")
    takeWhileFunc()

    println("\nFlatMap example")
    flatMapFunc()

    println("\nFlatMapIndexed example")
    flatMapIndexedFunc()

    println("\nPartition example")
    partitionFunc()

    println("\nMinBy and MAxBy examples")
    minByMaxBy()

    println("\nMinByOrNull and MaxByOrNull examples")
    minByMaxByOrNull()

    println("\nSumBy example")
    sumOfFunc()

    println("\nIndexOfFirst and IndexOfLast example")
    indexOfFirstIndexOfLastFuncs()

    println("\nFirstOrNull and LastOrNull examples")
    firstLastOrNull()

    println("\nFirst and Last examples")
    firstLastHighOrder()

    println("\nGroupBy example")
    groupByFunc()

    println("\nGroupingBy example")
    groupingByFunc()

    println("\nSortedBy and SortedByDescending examples")
    sortedBySortedByDescending()

    println("\nAssociate example")
    associateFunc()

    println("\nAssociateTo example")
    associateToFunc()

    println("\nAssociateBy example")
    associateByFunc()

    println("\nAssociateByTo example")
    associateByToFunc()

    println("\nAssociateWith example")
    associateWithFunc()

    println("\nAssociateWithTo example")
    associateWithToFunc()

    println("\nDistinctBy example")
    distinctByFunc()
}


fun forEachLoops() {
    val chars: List<Char> = listOf('a', 'b', 'c', 'd', 'e')
    println("Initial data: $chars")

    var forEachString = ""
    val forEachIndexedMap: MutableMap<Int, Char> = mutableMapOf()

    chars.forEach { forEachString += it }
    chars.forEachIndexed { index, v -> forEachIndexedMap[index + 1] = v }

    println("Adding chars together in a string using 'forEach': $forEachString")
    println("Mapping chars sequentially from 1 to 5 using 'forEachIndexed': $forEachIndexedMap")
}


fun mapAndFilter() {
    val nums: List<Int> = listOf(1, 2, 3, 4, 5, 6, 23, 90)
    println("Initial data: $nums")

    val smallNums: List<Int> = nums.filter { it < 10 }
    val squaredNums: List<Int> = nums.map { it * it }
    val smallSquaredNums: List<Int> = nums
        .filter { it < 10 }
        .map { it * it }

    println("Nums smaller than 10 using 'filter': $smallNums")
    println("Squared Nums using 'map': $squaredNums")
    println("Nums smaller than 10 and squared afterwards using 'filter' then 'map': $smallSquaredNums")
}


fun mapIndexedFunc() {
    val nums: List<Int> = listOf(1, 2, 3, 4, 5, 6)
    println("Initial data: $nums")

    val squaredAndIndexAddition = nums.mapIndexed { index, num ->
        (num * num) + index
    }

    println("Each element is squared, then added their index value to the operation using 'mapIndexed': $squaredAndIndexAddition")
}


fun filterIndexedFunc() {
    val nums = listOf(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
    println("Initial data: $nums")

    // select the numbers which are greater than 20, and which have an index divisible by 2
    val filterBasedOnIndex = nums.filterIndexed { index, value ->
        index % 2 == 0 && value > 20
    }

    println("Filter the numbers with even index and value greater than 20 using 'filterIndexed': $filterBasedOnIndex")
}


fun reduceAndFoldFuncs() {
    val nums: List<Int> = listOf(0, 1, 2, 3, 4)
    println("Initial data: $nums")

    // 'acc' is the current computed value, while 'i' is the next in list
    val sum: Int = nums.reduce { acc, i -> acc + i }
    println("Sum of nums is: $sum")

    // if current 'i' value equals 0 then use the 'acc' value which has an initial value of 1, else use 'i' value
    val product: Int = nums.fold(1) { acc, i ->
        if (i != 0) acc * i else acc
    }
    println("Product of nums is $product")
}


fun takeWhileFunc() {
    val nums: List<Int> = listOf(1, 2, 3, 4, 5)
    println("Initial data: $nums")

    val getBasedOnCondition: List<Int> = nums.takeWhile { it % 3 != 0 }
    println("all nums until any number is divisible by 3: $getBasedOnCondition")
}


fun flatMapFunc() {
    val nestedList: List<List<Int>> = listOf(listOf(1, 2), listOf(3, 4), listOf(5, 6))
    println("Initial data: $nestedList")

    val flattenAndMap: List<Int> = nestedList.flatMap { list -> list.map { elem -> elem * elem } }
    println("Map elements as squared, then flatten using 'flatMap': $flattenAndMap")
}


fun flatMapIndexedFunc() {
    val nestedList: List<List<Int>> = listOf(listOf(1, 2), listOf(3, 4), listOf(5, 6))
    println("Initial data: $nestedList")

    val flattenAndMapIndexed: List<Int> = nestedList.flatMapIndexed { index, list ->
        list.map { elem ->
            // each element is squared, and then the index value of its list container is added to it
            (elem * elem) + index
        }
    }

    println("Map elements as squared, then added the index value of their list container, then flatten using 'flatMapIndexed': $flattenAndMapIndexed")
}


fun partitionFunc() {
    val numbers: List<Int> = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    println("Initial data: $numbers")

    val (evenNumbers, oddNumbers) = numbers.partition { it % 2 == 0 }
    println("Get even numbers using 'partition': $evenNumbers") // returns [2, 4, 6, 8, 10]
    println("Get odd numbers using 'partition': $oddNumbers")   // returns [1, 3, 5, 7, 9]
}


fun minByMaxBy() {
    data class Item(val name: String, val price: Double, val count: Int)

    val items: List<Item> = listOf(
        Item(name = "car", price = 2000.90, count = 2),
        Item(name = "telephone", price = 500.75, count = 5),
        Item(name = "house", price = 175000.80, count = 3)
    )
    println("Initial data: \n Items: $items")

    val mostExpensiveItem: Item = items.maxBy { it.price }
    println("Get the most expensive item using 'maxBy': $mostExpensiveItem")

    val leastFrequentItem: Item = items.minBy { it.count }
    println("Get the least frequent item using 'minBy': $leastFrequentItem")
}


fun minByMaxByOrNull() {
    data class Product(val name: String, val price: Double)
    data class User(val name: String, val age: Int)

    // used to return null value (empty list)
    val users: List<User> = emptyList()

    // used to return existing value (populated list)
    val products: List<Product> = listOf(
        Product(name = "Apple", price = 2.50),
        Product(name = "Pear", price = 3.25),
        Product(name = "Banana", price = 5.75)
    )
    println("Initial data: \n Products: $products \n Users: $users")

    val mostExpensiveProduct: Product? = products.maxByOrNull { it.price }
    val mostCheapProduct: Product? = products.minByOrNull { it.price }
    val checkNull: User? = users.maxByOrNull { it.age }

    println("Get most expensive product using 'maxByOrNull': $mostExpensiveProduct")
    println("Get cheapest product using 'minByOrNull': $mostCheapProduct")
    println("Attempt to return user from an empty users list: $checkNull")
}


fun sumOfFunc() {
    data class Product(val name: String, val price: Double)

    val products: List<Product> = listOf(
        Product(name = "Laptop", price = 325.25),
        Product(name = "Phone", price = 200.75),
        Product(name = "Tablet", price = 100.50)
    )
    println("Initial data:")
    products.forEach { println(" $it") } // print initial data, one entry per line

    val totalPriceOfRounded: Int = products.sumOf { it.price.roundToInt() }
    println("Total of Rounded price per product using 'sumOf': $totalPriceOfRounded")
}


fun indexOfFirstIndexOfLastFuncs() {
    val people: List<String> = listOf("Ana", "Bill", "Chris", "Doug", "Elaine")
    println("Initial data: $people")

    val firstOccurrenceWithLeadingC = people.indexOfFirst { it.startsWith("C") } // returns 2 (Chris)
    println("Get the index of first word which starts with letter 'C' using 'indexOfFirst: $firstOccurrenceWithLeadingC")

    val firstOccurrenceWithLeadingG = people.indexOfFirst { it.startsWith("G") } // returns -1 (no entry)
    println("Get the index of first word which starts with letter 'G' using 'indexOfFirst' $firstOccurrenceWithLeadingG")

    val lastOccurrenceWithTrailingE = people.indexOfLast { it.endsWith("e") } // returns 5 (Elaine)
    println("Get the index of last word which ends with letter 'e' using 'indexOfLast': $lastOccurrenceWithTrailingE")

    val lastOccurrenceWithTrailingJ = people.indexOfLast { it.endsWith("j") } // returns -1 (no entry)
    println("Get the index of last word which ends with letter 'j' using 'indexOfLast': $lastOccurrenceWithTrailingJ")
}


fun firstLastHighOrder() {
    val nums: List<Int> = listOf(1, 2, 3, 4, 5, 6)
    println("Initial data: $nums")

    val firstDividedBy3 = nums.first { it % 3 == 0 }
    println("Get the first number divisible by 3 using 'first': $firstDividedBy3")

    val lastDividedBy3 = nums.last { it % 3 == 0 }
    println("Get the last number divisible by 3 using 'last': $lastDividedBy3")
}


fun firstLastOrNull() {
    val oddNums: List<Int> = listOf(1, 3, 5, 7, 9)
    println("Initial data: $oddNums")

    val firstOddNum: Int? = oddNums.firstOrNull { it % 2 == 1 }
    val firstEvenNum: Int? = oddNums.firstOrNull { it % 2 == 0 }

    val lastOddNum: Int? = oddNums.lastOrNull { it % 2 == 1 }
    val lastEvenNum: Int? = oddNums.lastOrNull { it % 2 == 0 }

    println("First odd num from collection: $firstOddNum")
    println("First even num from collection: $firstEvenNum")
    println("Last odd num from collection: $lastOddNum")
    println("Last even num from collection: $lastEvenNum")
}


fun groupByFunc() {
    data class User(val name: String, val age: Int, val country: String)

    val users: List<User> = listOf(
        User(name = "Dave", age = 28, country = "USA"),
        User(name = "Jenny", age = 17, country = "USA"),
        User(name = "Saxena", age = 28, country = "India"),
        User(name = "Sam", age = 42, country = "USA"),
        User(name = "Steve", age = 28, country = "UK"),
        User(name = "Dan", age = 17, country = "USA"),
        User(name = "Laxmi", age = 42, country = "India")
    )
    println("Initial data:")
    users.forEach { println(" $it") } // print initial data, one entry per line

    val groupByCountry: Map<String, List<User>> = users.groupBy { it.country }
    val groupByAge: Map<Int, List<User>> = users.groupBy { it.age }
    val groupByFirstLetter: Map<Char, List<User>> = users.groupBy { it.name[0] }

    // using transformations
    val groupByMajorVsMinor: Map<String, List<User>> = users.groupBy(
        // sets the key of the map to either "Major or Minor"
        keySelector = {
            if (it.age > 18) "Major" else "Minor"
        },
        valueTransform = { it }
    )

    // it will end up in 3 lines, since there are 3 countries (UK, USA, India)
    println("Users mapped by Country:")
    groupByCountry.forEach { println(" ${it.key} -> ${it.value}") }

    // it will also end up in 3 lines, since there are 3 age values (28, 17, 42)
    println("Users mapped by Age")
    groupByAge.forEach { println(" ${it.key} -> ${it.value}") }

    // it will end up in 4 lines, since there are 4 different letters (D, J, S, L)
    println("Users mapped by First Letter of the name using 'groupBy':")
    groupByFirstLetter.forEach { println(" ${it.key} -> ${it.value}") }

    // filter who is Major and who is Minor
    println("Users mapped by age, if age < 18, they are Minor, else Major using 'groupBy' with transformation:")
    groupByMajorVsMinor.forEach { println(" ${it.key} -> ${it.value}") }
}


fun groupingByFunc() {
    data class Product(val name: String, val category: String, val price: Double)

    val products: List<Product> = listOf(
        Product(name = "Pear", category = "Fruits", price = 2.50),
        Product(name = "Laptop", category = "Electronics", price = 1999.90),
        Product(name = "Beer", category = "Beverages", price = 2.50),
        Product(name = "Phone", category = "Electronics", price = 999.50),
        Product(name = "Apple", category = "Fruits", price = 1.75),
        Product(name = "Juice", category = "Beverages", price = 2.50),
        Product(name = "Coffee", category = "Beverages", price = 3.30)
    )
    println("Initial data:")
    products.forEach { println(" $it") } // print initial data, one entry per line

    val countByCategory: Map<String, Int> = products.groupingBy { it.category }.eachCount()
    val totalPricePerCategory: Map<String, Double> = products
        .groupingBy { it.category }
        .fold(0.0) { acc, i -> acc + i.price }

    println("Count of categories using 'groupingBy' with 'fold':")
    countByCategory.forEach { println(" ${it.key} -> ${it.value}") }

    println("Total Price per category using 'groupingBy':")
    totalPricePerCategory.forEach { println(" ${it.key} -> ${it.value}") }
}


fun sortedBySortedByDescending() {
    data class Person(val name: String, val age: Int)

    val persons: List<Person> = listOf(
        Person(name = "Ana", age = 23),
        Person(name = "Bill", age = 6),
        Person(name = "Chris", age = 18)
    )
    println("Initial data:")
    persons.forEach { println(" $it") } // print initial data, one entry per line

    val sortedByAsc = persons.sortedBy { it.age }
    println("Persons sorted by ascending order using 'sortedBy':")
    sortedByAsc.forEach { println(" $it") }

    val sortedByDesc = persons.sortedByDescending { it.age }
    println("Persons sorted by descending order using 'sortedByDescending':")
    sortedByDesc.forEach { println(" $it") }
}


fun associateFunc() {
    data class Shape(val name: String, val corners: Int)

    val shapes: List<Shape> = listOf(
        Shape("Square", 4),
        Shape("Triangle", 3),
        Shape("Pentagon", 5),
        Shape("Hexagon", 6),
        Shape("Circle", 0)
    )
    println("Initial data:")
    shapes.forEach { println(" $it") } // print initial data, one entry per line

    val shapeNameToCornerMap: Map<String, Int> = shapes.associate { it.name to it.corners }
    println("Shape names mapped to corners squared using 'associate':")
    shapeNameToCornerMap.forEach { println(" ${it.key} -> ${it.value * it.value}") }
}


fun associateToFunc() {
    data class Product(val id: Int, val name: String)

    val mutableMap = mutableMapOf<String, Int>() // target map which will be populated
    val products: List<Product> = listOf(
        Product(id = 1, name = "Laptop"),
        Product(id = 2, name = "Phone"),
        Product(id = 3, name = "Tablet"),
        Product(id = 4, name = "Headphones"),
        Product(id = 5, name = "Smartwatch")
    )
    println("Initial data:")
    products.forEach { println(" $it") } // print initial data, one entry per line

    products.associateTo(mutableMap) { it.name to it.id }
    println("Populate the mutableMap variable as key (name) to value (id) using 'associateTo':")
    mutableMap.forEach { println(" ${it.key} -> ${it.value}") }
}


fun associateByFunc() {
    data class Child(val id: Int, val name: String, val age: Int)

    val children: List<Child> = listOf(
        Child(id = 1, name = "Ana", age = 7),
        Child(id = 2, name = "Bill", age = 5),
        Child(id = 3, name = "Chris", age = 5),
        Child(id = 4, name = "Duncan", age = 7)
    )
    println("Initial data:")
    children.forEach { println(" $it") } // print initial data, one entry per line

    val associateById: Map<Int, Child> = children.associateBy { it.id }
    println("Children associated by id using 'associateBy':")
    associateById.forEach { println(" ${it.key} -> ${it.value}") }

    // this will return only Duncan (second child of 7 years old) and Chris (second child of 5 years old)
    val associateByRepeatedSelector: Map<Int, Child> = children.associateBy { it.age }
    println("Associating by age; Associating by repeated selector, picks only the last item from the list:")
    associateByRepeatedSelector.forEach { println(" ${it.key} -> ${it.value}") }

    // associate using specific value transform, in this case (Name -> Age)
    val associateByUsingTransform: Map<String, Int> = children.associateBy(
        keySelector = { it.name },
        valueTransform = { it.age }
    )
    println("Associating using keySelector and valueTransform:")
    associateByUsingTransform.forEach { println(" ${it.key} -> ${it.value}") }
}


fun associateByToFunc() {
    data class Product(val id: Int, val name: String, val price: Double)

    val mutableMap = mutableMapOf<Int, Product>() // target map which will be populated
    val transformedMap = mutableMapOf<Int, Int>() // target map which for transformation
    val products: List<Product> = listOf(
        Product(id = 1, name = "Laptop", price = 950.50),
        Product(id = 2, name = "Phone", price = 875.55),
        Product(id = 3, name = "Tablet", price = 250.75),
        Product(id = 4, name = "Headphones", price = 880.00),
        Product(id = 5, name = "Smartwatch", price = 180.25)
    )
    println("Initial data:")
    products.forEach { println(" $it") } // print initial data, one entry per line

    products.associateByTo(mutableMap) { it.price.toInt() }
    println("Populate the mutable Map variable as key (price to Int) to value (Product) using 'associateByTo':")
    mutableMap.forEach { println(" ${it.key} -> ${it.value}") }

    products.associateByTo(
        destination = transformedMap,
        keySelector = { it.id },
        valueTransform = { it.price.toInt() }
    )
    println("Populate the mutable Map variable as key (id) to value {price to Int} using keySelector and valueTransform:")
    transformedMap.forEach { println(" ${it.key} -> ${it.value}") }
}


fun associateWithFunc() {
    data class Student(val name: String, val grade: Int)

    val students: List<Student> = listOf(
        Student(name = "Alice", grade = 10),
        Student(name = "Bob", grade = 2),
        Student(name = "Chuck", grade = 1),
        Student(name = "David", grade = 4),
        Student(name = "Elaine", grade = 5)
    )
    println("Initial data:")
    students.forEach { println(" $it") } // print initial data, one entry per line

    // transform values to Fail, Pass or Cheated based on the values (grades in this case)
    val studentGrades = students.associateWith { student ->
        when (student.grade) {
            in 2..4 -> "Fail"
            1 -> "Cheated"
            else -> "Pass"
        }
    }
    println("Associate students with Pass, Fail or Cheated based on their grades using 'associateWith':")
    studentGrades.forEach { println(" ${it.key} -> ${it.value}") }
}


fun associateWithToFunc() {
    data class Car(val name: String, val price: Double)

    val mutableMap = mutableMapOf<Car, String>()
    val cars: List<Car> = listOf(
        Car("Skoda", 4850.50),
        Car("BMW", 9850.00),
        Car("Renault", 3500.00),
        Car("Mercedes", 8900.25),
        Car("Dacia", 2900.90)
    )
    println("Initial data:")
    cars.forEach { println(" $it") } // print initial data, one entry per line

    // Transform values to "Luxury", "Premium", "Standard", "Economy based on the prices, and add them to mutableMap variable
    cars.associateWithTo(mutableMap) { car ->
        when {
            car.price > 8000 -> "Luxury"
            car.price > 5000 -> "Premium"
            car.price > 3000 -> "Standard"
            else -> "Economy"
        }
    }

    println("Associate Cars with Cheap or Expensive in the form key(car name) -> value (Expensiveness) using 'associateWithTo':")
    mutableMap.forEach { println(" ${it.key} -> ${it.value}") }
}


fun distinctByFunc() {
    data class Product(val id: Int, val name: String)

    val products: List<Product> = listOf(
        Product(1, "Laptop"),
        Product(2, "Phone"),
        Product(3, "Tablet"),
        Product(1, "Laptop"), // duplicate
        Product(2, "Phone"), // duplicate
        Product(3, "Tablet"), // duplicate
    )
    println("Initial data:")
    products.forEach { println(" $it") } // print initial data, one entry per line

    // remove duplicates based on id
    val uniqueProducts = products.distinctBy { it.id }

    println("Get Unique products using 'distinctBy':")
    uniqueProducts.forEach { println(" $it") }
}
